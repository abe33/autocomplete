
## Very preliminary API 0.0.1

An API to facilitate the goals outlined in the architecture document.

## High-level API contract

 The API is designed to roughly support this contract:

Provider receives:

- AST of current file
- Location of cursor within AST

Provider returns:

- Display hint
- Display label
- Snippet text
- Range to replace if snippet is inserted

---

## The API is Actually Multiple APIs

The overall API consists of three specific APIs.  The `Parser API` facilitates a `parse provider` to parse the raw textfile, produce a pseudo-AST, and generate word collections for scopes in the AST.  

The second `logic API` is for a `logic provider`.  It has an intelligent "search engine" that generates the suggestions like those in the second part of the contract section above ("provider returns").

The final `responder API` supports a `responder provider`.  This provider is handed the text around the cursor and parts of the AST and suggestions created by the `logic provider`. The `responder provider` is only given scopes that surround the cursor.  

The design goal for the `respoder provider` is to have as little work to do as possible.  It will actually be called once for each scope. 

## APM Modules

Providers are Atom packages installed using APM.  They have no activation events and are activated when atom loads.  However, all they do is register themselves at load time. One package may include multiple providers such as one each of the three types: parser, logic, and responder.

We must make sure the `autocomplete` package is already loaded when they register.  Unless/until Atom provides such a feature the provider packages will need to wrap their registration calls in process.nextTick to delay them.

## API Control Flow

The providers are called by master code as they are needed.  A lot of information is included in the main call so they don't have to do a lot of querying in the reverse direction.  The `logic provider` is the only one doing any significant amount of querying as it is searching for suggestions.

## Response performance

As part of the architecure goals, `autocomplete` must begin the computation of suggestions at the first keystroke and restart it on each following keystroke.  There is no practical way to abort a provider so the real-time computation must be divided into short bursts.  

Calls from a master controller to the `responder provider` will trigger each burst. The computation must be stateless within each burst. The master will fire off multiple calls until the next key is pressed and then the series of calls will start over again.

The whole reason the `responder provider` exists is to allow computation in short bursts using specialized data generated by the `logic provider` to allow this. The `logic provider` executes in much longer runs in a separate OS process.

## The Parser API

Calls to the master

-- registerParser 





